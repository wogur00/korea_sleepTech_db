### 'j_정규화' 폴더 >>> 'BCNF정규화' 파일 ###

### 보이스-코드(Boyce-Codd) 정규화 ###
# : 3.5 정규화
# : '모든 결정자'가 '후보키(유일성, 최소성)'가 되어야 한다는 조건을 만족하는 정규형
# - 3NF(제3정규형) 조건을 만족하면서도 + 모든 후보키가 후보키

-- cf) 후보키(Candidate Key)
# : 테이블의 각 행을 유일하게 식별할 수 있는 최소한의 속성 집합
# >> 유일성과 최소성을 가짐
# EX) 학생 테이블에서 '학번', '나이', '성별' 중에서
#		'학번'은 각 학생을 유일하게 식별할 수 있음 >> '후보키' // '나이'와 '성별'을 제거해도 학생 구별 가능

# +) 기본키를 제외한 나머지 후보키: 대체키

-- VS 기본키(Primary Key)
#		: 후보키들 중! 메인으로 선정되는 키 
#       >> 유일성과 최소성을 가짐
#		cf) 기본키와 다른 후보키들과의 차이
			# 값의 변동이 잦은 후보키는 기본키로 부적절
            # Null 값을 가질 수 있는 후보키는 부적절
            # 하나의 테이블에서 반드시 하나의 기본키만 존재!

-- cf) 결정자(Determinant)
# : 어떤 속성 집합이 다른 속성을 '결정(함수 종속)'할 수 있다면 그 속성 집합은 '결정자'

# ----------------------------------------------------#
/*
	'모든 결정자'가 '후보키(유일성, 최소성)'가 되어야 한다는 조건
    
    cf) 유일성-중복X, 최소성-최소한의 속성들로만 키를 구성
    
    1. 학생ID, 학생명, 학생나이, 과목ID
    
    2. 과목ID, 과목명
		>> 과목ID가 과목명을 결정한다면(함수 종속)일 경우 과목ID는 결정자이며! 반드시 후보키여야 함!
*/
use `normalization`;
create table example_3nf (
	# 3NF는 만족하지만 BCNF는 위반한 경우
    student_id int,
    student_name varchar(100),
    course_id varchar(100), -- 과목 코드: '결정자' 
    score int,
    course_name varchar(100), -- 과정명은 과목코드가 결정
    primary key (student_id, course_id) -- 복합키(학생번호 + 과목번호)
);

# 후보키: 모든 속성을 '유일'하게 식별할 수 있는 '최소' 속성 집합
# >> 여러 개의 후보키중 하나가 PK로 선정

# 복합 기본키: 여러 속성의 '조합'으로 한 행(row)를 유일하게 식별하는 '선택'된 후보키

### BCNF 위반 이유: course_id는 결정자이지만 후보키가 아님 ###
create table 과목 (
	과목코드 varchar(10) primary key, -- 결정자가 후보키가 됨!
    과목명 varchar(50)
);

create table 성적 (
	학번 varchar(10),
    과목코드 varchar(10),
    점수 int,
    primary key (학번, 과목코드),
    foreign key (과목코드) references 과목(과목코드)
);

insert into 과목 values
	('123', '챗봇'),
	('234', '빅데이터');
    
insert into 성적
values
	('101', '123', 95),
	('102', '234', 85),
	('103', '123', 100);